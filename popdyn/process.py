import numpy as np
import os
from skimage.io import imread, imsave
from scipy.ndimage import distance_transform_edt
import matplotlib.pyplot as plt

# Image frame to start from and step between frames
start_frame = 10
step = 1
nframes = 60
pos = 5
# Position and velocity arrays from velocimetry
vel = np.load(f'/media/guillermo/Expansion/Thesis GY/3. Analyzed files/Ti scope/2023_11_28/velocity_data/pos6/vel.np.npy')
pos = np.load(f'/media/guillermo/Expansion/Thesis GY/3. Analyzed files/Ti scope/2023_11_28/velocity_data/pos6/pos.np.npy')

# Size of data
nx, ny, nt, _ = vel.shape

# Load the tif image from the microscope
# im_all = imread('../10x_1.5x_-5_pAAA_MG_1_MMStack_Pos9.ome.tif')
# im_all = imread('../Fused_12_13_14_15_1024.bgcorr.tiff')
# im_all = imread('../10x_1.5x_-5_pAAA_MG_1_MMStack_Pos8.ome.tif')
im_all = imread(f'/media/guillermo/Expansion/Thesis GY/3. Analyzed files/Ti scope/2023_11_28/2023_11_28_10x_1.0x_pAAA_Ti_Pos6.ome.tif')
edt = np.load(f"/media/guillermo/Expansion/Thesis GY/3. Analyzed files/Ti scope/2023_11_28/results/pos6/edt.npy")

# Load the mask generated by trainable weka
# mask_all = imread('../C2-10x_1.5x_-5_pAAA_MG_1_MMStack_Pos9.contour.mask.ome.tif')
# mask_all = imread('../C2-10x_1.5x_-5_pAAA_MG_1_MMStack_Pos8_phase.contour.mask.ome.tif')
mask_all = imread(f'/media/guillermo/Expansion/Thesis GY/3. Analyzed files/Ti scope/2023_11_28/contour_masks/mask_2023_11_28_10x_1.0x_pAAA_Ti_Pos6.ome.tif')
mask_all = mask_all > 0

#nt, nx, ny, nc = im_all.shape
# mask_all = np.zeros(im_all.shape[:3])
x, y = np.meshgrid(np.arange(1200), np.arange(1200))
# cx,cy = 320,500
# r = np.sqrt((x-cy)**2 + (y-cx)**2)
# mask = r<300
# for frame in range(im_all.shape[0]):
#    mask_all[frame,:,:] = mask
# mask_all = (mask_all==True)*1

# Make arrays to store results
radpos = np.zeros((nt, nx, ny))
vmag = np.zeros((nt, nx, ny))
vrad = np.zeros((nt, nx, ny))
vtheta = np.zeros((nt, nx, ny))

#edt = np.zeros((nt, 1200, 1200))

# Process the data and save results
for frame in range(nt):
    print(f'Processing frame {frame}')

    mask = mask_all[start_frame + frame * step + 1, :, :]
    cx = x[mask > 0].mean()
    cy = y[mask > 0].mean()

    vx = vel[:, :, frame, 0]
    vy = vel[:, :, frame, 1]

    # Subtract drift from velocities
    vx -= np.nanmean(vx)
    vy -= np.nanmean(vy)

    # Compute distance of each pixel from colony edge
    #edt[frame, :, :] = distance_transform_edt(mask)
    # edt[frame,:,:] = distance_transform_edt(mask_all[frame*step,:,:])

    # Get direction to colony edge as negative of gradient of distance
    gradx, grady = np.gradient(edt[start_frame + frame * step + 1, :, :])
    gradx[mask == 0] = np.nan
    grady[mask == 0] = np.nan
    px = pos[:, :, frame, 0].astype(int)
    py = pos[:, :, frame, 1].astype(int)
    pnorm = np.sqrt((px - cx) ** 2 + (py - cy) ** 2)

    gx = np.zeros((nx, ny))
    gy = np.zeros((nx, ny))
    for ix in range(nx):
        for iy in range(ny):
            gx[ix, iy] = -np.nanmean(gradx[px[ix, iy]:px[ix, iy] + 64, py[ix, iy]:py[ix, iy] + 64])
            gy[ix, iy] = -np.nanmean(grady[px[ix, iy]:px[ix, iy] + 64, py[ix, iy]:py[ix, iy] + 64])
            # radpos[frame,ix,iy] = np.nanmean(edt[frame, px[ix,iy]-32:px[ix,iy]+32, py[ix,iy]-32:py[ix,iy]+32])
    # Compute magnitude of velocities in radial direction
    velnorm = np.sqrt(vx ** 2 + vy ** 2)
    gnorm = np.sqrt(gx ** 2 + gy ** 2)
    vmag[frame, :, :] = vx * gx + vy * gy
    vrad[frame, :, :] = vmag[frame, :, :] / velnorm / gnorm
    vperp = vx * gy - vy * gx
    vtheta[frame, :, :] = vperp / velnorm / gnorm

    # Radial position of each grid square
    radpos[frame, :, :] = edt[frame, px + 16, py + 16]

# Area and estimated radius of colony
# area = mask_all[start_frame:start_frame + nt*step:step,:,:].sum(axis=(1,2))
#area = mask_all[start_frame:start_frame + nt * step:step, :, :].sum(axis=(1, 2))
#radius = np.sqrt(area / np.pi)

# Save results

path = f'/media/guillermo/Expansion/Thesis GY/3. Analyzed files/Ti scope/2023_11_28/results/pos6'
os.path.join(path)
np.save(os.path.join(path,'radpos.npy'), radpos)
#np.save(os.path.join(path,'radpos.npy')'results/edt.npy', edt)
np.save(os.path.join(path,'vmag.npy'), vmag)
np.save(os.path.join(path,'vrad.npy'), vrad)
np.save(os.path.join(path,'vtheta.npy'), vtheta)
#np.save(os.path.join(path,'radpos.npy')'results/area.npy', area)
#np.save(os.path.join(path,'radpos.npy')'results/radius.npy', radius)
